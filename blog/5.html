<!doctype html>
<html>
<head>
    
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>How Lamport Signatures Work And My Rust Implementation</title><link href='https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text/css' /><style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; overflow-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 40px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write li > figure:last-child { margin-bottom: 0.5rem; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; }
button, input, select, textarea { color: inherit; font: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
p { line-height: inherit; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 2; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px !important; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  html.blink-to-pdf { font-size: 13px; }
  .typora-export #write { padding-left: 32px; padding-right: 32px; padding-bottom: 0px; break-after: avoid; }
  .typora-export #write::after { height: 0px; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
[contenteditable="true"]:active, [contenteditable="true"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.html-for-mac .inline-math-svg .MathJax_SVG { vertical-align: 0.2px; }
.md-math-block .MathJax_SVG_Display { text-align: center; margin: 0px; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; overflow-y: hidden; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: var(--monospace); }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none 0s ease 0s; }
.MathJax_SVG_Display svg { vertical-align: middle !important; margin-bottom: 0px !important; margin-top: 0px !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="mermaid"] svg, [lang="flow"] svg { max-width: 100%; height: auto; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }
svg[id^="mermaidChart"] { line-height: 1em; }
mark { background: rgb(255, 255, 0); color: rgb(0, 0, 0); }
.md-html-inline .md-plain, .md-html-inline strong, mark .md-inline-math, mark strong { color: inherit; }
mark .md-meta { color: rgb(0, 0, 0); opacity: 0.3 !important; }


.CodeMirror { height: auto; }
.CodeMirror.cm-s-inner { background: inherit; }
.CodeMirror-scroll { overflow: auto hidden; z-index: 3; }
.CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); }
.CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); background: inherit; white-space: nowrap; }
.CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); }
.cm-s-inner .cm-keyword { color: rgb(119, 0, 136); }
.cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); }
.cm-s-inner .cm-number { color: rgb(17, 102, 68); }
.cm-s-inner .cm-def { color: rgb(0, 0, 255); }
.cm-s-inner .cm-variable { color: rgb(0, 0, 0); }
.cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); }
.cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); }
.cm-s-inner .cm-string { color: rgb(170, 17, 17); }
.cm-s-inner .cm-property { color: rgb(0, 0, 0); }
.cm-s-inner .cm-operator { color: rgb(152, 26, 26); }
.cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); }
.cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); }
.cm-s-inner .cm-meta { color: rgb(85, 85, 85); }
.cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); }
.cm-s-inner .cm-builtin { color: rgb(51, 0, 170); }
.cm-s-inner .cm-bracket { color: rgb(153, 153, 119); }
.cm-s-inner .cm-tag { color: rgb(17, 119, 0); }
.cm-s-inner .cm-attribute { color: rgb(0, 0, 204); }
.cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); }
.cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); }
.cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); }
.cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); }
.cm-negative { color: rgb(221, 68, 68); }
.cm-positive { color: rgb(34, 153, 34); }
.cm-header, .cm-strong { font-weight: 700; }
.cm-del { text-decoration: line-through; }
.cm-em { font-style: italic; }
.cm-link { text-decoration: underline; }
.cm-error { color: red; }
.cm-invalidchar { color: red; }
.cm-constant { color: rgb(38, 139, 210); }
.cm-defined { color: rgb(181, 137, 0); }
div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); }
div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); }
.cm-s-inner .CodeMirror-activeline-background { background: inherit; }
.CodeMirror { position: relative; overflow: hidden; }
.CodeMirror-scroll { height: 100%; outline: 0px; position: relative; box-sizing: content-box; background: inherit; }
.CodeMirror-sizer { position: relative; }
.CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; }
.CodeMirror-vscrollbar { right: 0px; top: 0px; overflow: hidden; }
.CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow: hidden; }
.CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; }
.CodeMirror-gutter-filler { left: 0px; bottom: 0px; }
.CodeMirror-gutters { position: absolute; left: 0px; top: 0px; padding-bottom: 30px; z-index: 3; }
.CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; }
.CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: none !important; }
.CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; }
.CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; }
.CodeMirror-lines { cursor: text; }
.CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; overflow-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; }
.CodeMirror-wrap pre { overflow-wrap: break-word; white-space: pre-wrap; word-break: normal; }
.CodeMirror-code pre { border-right: 30px solid transparent; width: fit-content; }
.CodeMirror-wrap .CodeMirror-code pre { border-right: none; width: auto; }
.CodeMirror-linebackground { position: absolute; left: 0px; right: 0px; top: 0px; bottom: 0px; z-index: 0; }
.CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; }
.CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; }
.CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; }
.CodeMirror-measure pre { position: static; }
.CodeMirror div.CodeMirror-cursor { position: absolute; visibility: hidden; border-right: none; width: 0px; }
.CodeMirror div.CodeMirror-cursor { visibility: hidden; }
.CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; }
.cm-searching { background: rgba(255, 255, 0, 0.4); }
@media print {
  .CodeMirror div.CodeMirror-cursor { visibility: hidden; }
}


:root {
    --side-bar-bg-color: #fafafa;
    --control-text-color: #777;
}

@include-when-export url(https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext);

html {
    font-size: 16px;
}

body {
    font-family: "Open Sans","Clear Sans","Helvetica Neue",Helvetica,Arial,sans-serif;
    color: rgb(51, 51, 51);
    line-height: 1.6;
}

#write {
    max-width: 860px;
  	margin: 0 auto;
  	padding: 30px;
    padding-bottom: 100px;
}
#write > ul:first-child,
#write > ol:first-child{
    margin-top: 30px;
}

a {
    color: #4183C4;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 1rem;
    font-weight: bold;
    line-height: 1.4;
    cursor: text;
}
h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}
h1 tt,
h1 code {
    font-size: inherit;
}
h2 tt,
h2 code {
    font-size: inherit;
}
h3 tt,
h3 code {
    font-size: inherit;
}
h4 tt,
h4 code {
    font-size: inherit;
}
h5 tt,
h5 code {
    font-size: inherit;
}
h6 tt,
h6 code {
    font-size: inherit;
}
h1 {
    padding-bottom: .3em;
    font-size: 2.25em;
    line-height: 1.2;
    border-bottom: 1px solid #eee;
}
h2 {
   padding-bottom: .3em;
    font-size: 1.75em;
    line-height: 1.225;
    border-bottom: 1px solid #eee;
}
h3 {
    font-size: 1.5em;
    line-height: 1.43;
}
h4 {
    font-size: 1.25em;
}
h5 {
    font-size: 1em;
}
h6 {
   font-size: 1em;
    color: #777;
}
p,
blockquote,
ul,
ol,
dl,
table{
    margin: 0.8em 0;
}
li>ol,
li>ul {
    margin: 0 0;
}
hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

li p.first {
    display: inline-block;
}
ul,
ol {
    padding-left: 30px;
}
ul:first-child,
ol:first-child {
    margin-top: 0;
}
ul:last-child,
ol:last-child {
    margin-bottom: 0;
}
blockquote {
    border-left: 4px solid #dfe2e5;
    padding: 0 15px;
    color: #777777;
}
blockquote blockquote {
    padding-right: 0;
}
table {
    padding: 0;
    word-break: initial;
}
table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}
table tr:nth-child(2n),
thead {
    background-color: #f8f8f8;
}
table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    margin: 0;
    padding: 6px 13px;
}
table tr td {
    border: 1px solid #dfe2e5;
    margin: 0;
    padding: 6px 13px;
}
table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}
table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

.CodeMirror-lines {
    padding-left: 4px;
}

.code-tooltip {
    box-shadow: 0 1px 1px 0 rgba(0,28,36,.3);
    border-top: 1px solid #eef2f2;
}

.md-fences,
code,
tt {
    border: 1px solid #e7eaed;
    background-color: #f8f8f8;
    border-radius: 3px;
    padding: 0;
    padding: 2px 4px 0px 4px;
    font-size: 0.9em;
}

code {
    background-color: #f3f4f4;
    padding: 0 2px 0 2px;
}

.md-fences {
    margin-bottom: 15px;
    margin-top: 15px;
    padding-top: 8px;
    padding-bottom: 6px;
}


.md-task-list-item > input {
  margin-left: -1.3em;
}

@media print {
    html {
        font-size: 13px;
    }
    table,
    pre {
        page-break-inside: avoid;
    }
    pre {
        word-wrap: break-word;
    }
}

.md-fences {
	background-color: #f8f8f8;
}
#write pre.md-meta-block {
	padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block>.code-tooltip {
	bottom: .375rem;
}

.md-mathjax-midline {
    background: #fafafa;
}

#write>h3.md-focus:before{
	left: -1.5625rem;
	top: .375rem;
}
#write>h4.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
#write>h5.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
#write>h6.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
.md-image>.md-meta {
    /*border: 1px solid #ddd;*/
    border-radius: 3px;
    padding: 2px 0px 0px 4px;
    font-size: 0.9em;
    color: inherit;
}

.md-tag {
    color: #a7a7a7;
    opacity: 1;
}

.md-toc { 
    margin-top:20px;
    padding-bottom:20px;
}

.sidebar-tabs {
    border-bottom: none;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

/** focus mode */
.on-focus-mode blockquote {
    border-left-color: rgba(85, 85, 85, 0.12);
}

header, .context-menu, .megamenu-content, footer{
    font-family: "Segoe UI", "Arial", sans-serif;
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state{
    visibility: visible;
}

.mac-seamless-mode #typora-sidebar {
    background-color: #fafafa;
    background-color: var(--side-bar-bg-color);
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

#md-notification .btn {
    border: 0;
}

.dropdown-menu .divider {
    border-color: #e5e5e5;
}

.ty-preferences .window-content {
    background-color: #fafafa;
}

.ty-preferences .nav-group-item.active {
    color: white;
    background: #999;
}


</style>
</head>
<body class='typora-export os-windows' >
<div  id='write'  class = 'is-node'><h1><a name="introduction-to-lamport-signatures" class="md-header-anchor"></a><span>Introduction To Lamport Signatures</span></h1><div class='md-toc' mdtype='toc'><p class="md-toc-content" role="list"><span role="listitem" class="md-toc-item md-toc-h1" data-ref="n1658"><a class="md-toc-inner" href="#introduction-to-lamport-signatures">Introduction To Lamport Signatures</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n3"><a class="md-toc-inner" href="#preface">Preface</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n23"><a class="md-toc-inner" href="#introduction">Introduction</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n27"><a class="md-toc-inner" href="#what-is-a-digital-signature">What Is A Digital Signature?</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n44"><a class="md-toc-inner" href="#what-is-a-one-time-signature">What Is A One-Time Signature</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n47"><a class="md-toc-inner" href="#what-is-a-hash-function">What Is A Hash Function?</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n67"><a class="md-toc-inner" href="#how-does-binary-and-hexadecimal-work">How Does Binary and Hexadecimal Work?</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n80"><a class="md-toc-inner" href="#what-is-randomness">What Is Randomness?</a></span><span role="listitem" class="md-toc-item md-toc-h1" data-ref="n92"><a class="md-toc-inner" href="#how-lamport-signatures-work">How Lamport Signatures Work</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n94"><a class="md-toc-inner" href="#overview">Overview</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n95"><a class="md-toc-inner" href="#the-basic-idea">The Basic Idea</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n106"><a class="md-toc-inner" href="#planning-phase">Planning Phase</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n126"><a class="md-toc-inner" href="#generation-phase">Generation Phase</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n139"><a class="md-toc-inner" href="#signing-phase">Signing Phase</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n153"><a class="md-toc-inner" href="#verification-phase">Verification Phase</a></span><span role="listitem" class="md-toc-item md-toc-h1" data-ref="n166"><a class="md-toc-inner" href="#how-winternitz-one-time-signatures-work">How Winternitz One-Time Signatures Work</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n167"><a class="md-toc-inner" href="#overview-n167">Overview</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n169"><a class="md-toc-inner" href="#the-basic-idea-n169">The Basic Idea</a></span><span role="listitem" class="md-toc-item md-toc-h1" data-ref="n192"><a class="md-toc-inner" href="#my-reference-implementation-of-lamport-signatures">My Reference Implementation of Lamport Signatures</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n195"><a class="md-toc-inner" href="#why-do-i-believe-it-is-secure">Why Do I Believe It Is Secure?</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n204"><a class="md-toc-inner" href="#how-to-use">How To Use</a></span><span role="listitem" class="md-toc-item md-toc-h3" data-ref="n205"><a class="md-toc-inner" href="#secure-generation">Secure Generation</a></span><span role="listitem" class="md-toc-item md-toc-h2" data-ref="n207"><a class="md-toc-inner" href="#more-information">More Information</a></span><span role="listitem" class="md-toc-item md-toc-h1" data-ref="n1437"><a class="md-toc-inner" href="#homepage">Homepage</a></span></p></div><h2><a name="preface" class="md-header-anchor"></a><span>Preface</span></h2><p><span>Read </span><a href='https://en.wikipedia.org/wiki/Lamport_signature'><span>Wikipedia - Lamport Signatures</span></a></p><hr /><p><span>I am not a cryptographer so if I get anything wrong, please let me know.</span></p><p><span>There will be </span><strong><span>three people</span></strong><span> that view this blog post:</span></p><ul><li><p><span>The one that is </span><strong><span>new to cryptography</span></strong><span> and </span><strong><span>will want to read the entire post start to finish</span></strong><span>.</span></p><ul><li><span>For you, start from the beginning.</span></li></ul></li><li><p><span>The one that </span><strong><span>understands cryptography</span></strong><span> and wants to learn about </span><strong><span>Lamport Signatures</span></strong><span> and/or </span><strong><span>Winternitz-OTS</span></strong><span> (unfinished)</span></p><ul><li><span>For you, read the </span><strong><span>introduction</span></strong><span> and then skip to &quot;How Lamport Signatures Work&quot;</span></li></ul></li><li><p><span>The one that </span><strong><span>understands and solely wants to read about how my implementation works</span></strong><span>.</span></p><ul><li><span>For you, skip to &quot;My Reference Implementation of Lamport Signatures&quot;</span></li></ul></li></ul><h2><a name="introduction" class="md-header-anchor"></a><span>Introduction</span></h2><p><strong><span>Lamport Signatures</span></strong><span>, introduced by </span><a href='https://en.wikipedia.org/wiki/Leslie_Lamport'><span>Leslie Lamport</span></a><span> in 1979, are a </span><strong><span>One-Time, Post-Quantum, Digital Signature Scheme</span></strong><span> that use </span><strong><span>Hash Functions</span></strong><span> for its Digital Signatures.</span></p><p><span>Many digital signature schemes have been invented following the publication of Lamport Signatures that follow a scheme similar to Lamport Signatures by using Hash Functions as a way to create digital signatures. An example can be found in </span><a href='https://tools.ietf.org/html/rfc8391'><span>RFC8391 (XMSS)</span></a><span>, a standardized digital signature scheme that uses </span><strong><span>Winternitz-OTS+</span></strong><span>, an upgraded version of </span><strong><span>W-OTS</span></strong><span>, which in itself, is an upgraded version of </span><strong><span>Lamport Signatures</span></strong><span>.</span></p><p><span>A recent example can be found in the </span><strong><span>NIST PQ Round 2 Candidate</span></strong><span> </span><a href='https://sphincs.org/'><span>SPHINCS+</span></a><span>, which is a </span><strong><span>stateless hash-based signature scheme</span></strong><span> that uses the hashing functions Haraka, SHA256, and SHAKE256.</span></p><h2><a name="what-is-a-digital-signature" class="md-header-anchor"></a><span>What Is A Digital Signature?</span></h2><p><span>A </span><strong><span>Digital Signature</span></strong><span> is almost like a signature in real life. It proves that you signed something, but in the case of Digital Signatures, they use cryptography and mathematics to prove that you signed something using some given </span><strong><span>Keypair</span></strong><span>, usually with the private key (or sometimes secret key) creating the signature itself.</span></p><p><span>These </span><strong><span>Keypairs</span></strong><span> are referred to as:</span></p><ul><li><strong><span>The Public Key</span></strong></li><li><strong><span>The Private Key</span></strong><span> (or Secret Key)</span></li></ul><p><span>As the names suggests,</span></p><ul><li><p><span>The </span><strong><span>Public Key</span></strong><span> is Public for all verifiers to check against the </span><strong><span>signature</span></strong><span> to verify the signature is valid.</span></p></li><li><p><span>The </span><strong><span>Private Key (or Secret Key)</span></strong><span> is kept to the prover and used to </span><strong><span>generate the digital signature itself</span></strong><span> but never revealed</span></p><ul><li><span>an exception to this rule is found in Lamport Signatures as they are labeled One-Time Signature Schemes</span></li></ul></li></ul><h2><a name="what-is-a-one-time-signature" class="md-header-anchor"></a><span>What Is A One-Time Signature</span></h2><p><span>A </span><strong><span>One-Time Signature</span></strong><span> is a type of signature scheme where using the private key, you can only sign data once. Some digital signature schemes allow multiple signatures from a single private key, allowing you to keep the private key secure and continue signing messages with it.</span></p><p><span>In a </span><strong><span>One-Time Signature</span></strong><span>, the </span><strong><span>private key is usually revealed after signing</span></strong><span> making it only useable for a digital signature scheme once.</span></p><h2><a name="what-is-a-hash-function" class="md-header-anchor"></a><span>What Is A Hash Function?</span></h2><p><span>Read </span><a href='https://crypto.stackexchange.com/questions/47809/why-havent-any-sha-256-collisions-been-found-yet/47810#47810'><span>Stackoverflow - Why haven&#39;t any SHA-256 collisions been found yet?</span></a></p><p><img src="https:\\0xAtropine.github.io\blog\5\Hash.png" referrerpolicy="no-referrer" alt="Cryptographic Hash Functions: Definition &amp; Examples | Study.com"></p><p><span>The first piece of cryptographic knowledge you need to know is what a </span><strong><span>Cryptographic Hash Function</span></strong><span> is and what it can be defined as (per wikipedia):</span></p><blockquote><p><span>A </span><strong><span>cryptographic hash function</span></strong><span> (</span><strong><span>CHF</span></strong><span>) is a </span><a href='https://en.wikipedia.org/wiki/Hash_function'><span>hash function</span></a><span> that is suitable for use in </span><a href='https://en.wikipedia.org/wiki/Cryptography'><span>cryptography</span></a><span>. It is a mathematical </span><a href='https://en.wikipedia.org/wiki/Algorithm'><span>algorithm</span></a><span> that </span><a href='https://en.wikipedia.org/wiki/Map_(mathematics)'><span>maps</span></a><span> data of arbitrary size (often called the &quot;message&quot;) to a </span><a href='https://en.wikipedia.org/wiki/Bit_string'><span>bit string</span></a><span> of a fixed size (the &quot;hash value&quot;, &quot;hash&quot;, or &quot;message digest&quot;) and is a </span><a href='https://en.wikipedia.org/wiki/One-way_function'><span>one-way function</span></a><span>, that is, a function which is practically infeasible to invert. Ideally, the only way to find a message that produces a given hash is to attempt a </span><a href='https://en.wikipedia.org/wiki/Brute-force_search'><span>brute-force search</span></a><span> of possible inputs to see if they produce a match, or use a </span><a href='https://en.wikipedia.org/wiki/Rainbow_table'><span>rainbow table</span></a><span> of matched hashes. Cryptographic hash functions are a basic tool of modern cryptography.</span></p></blockquote><p><span>To summarize that, it is a one-way function that takes as input a length of any size and computes it to a fixed length.</span></p><hr /><p><strong><span>Collisions</span></strong><span> are when two different inputs to the same hash function result in the same output.</span></p><p><span>In reality, there will always be </span><strong><span>infinite collisions</span></strong><span> as their are infinite arbitrary sized-inputs, but for practicably, we make assumptions about the hardness of finding collisions, like in </span><strong><span>SHA256</span></strong><span>, the digest-size is 256 bits, which means there are </span><strong><span>2</span><sup><span>256</span></sup><span> possible outputs</span></strong><span>.</span></p><p><span>This means that the output will look something like this but it would only be 1s and 0s that represent a large number (2</span><sup><span>256</span></sup><span>):</span></p><blockquote><p><strong><span>SHA256:</span></strong><span> 216A6DC4FD320DBCB44E947587442546E7E3C3689BF559BBA7C08D5ADD64685D</span></p></blockquote><p><span>As of right now, </span><strong><span>no collisions</span></strong><span> has never been found for SHA256. Finding a collision would follow the following formula:</span></p><p><span>I&#39;ll just leave this </span><a href='https://crypto.stackexchange.com/a/47810'><span>here</span></a></p><blockquote><p><span>Bitcoin was computing </span><a href='https://en.bitcoin.it/wiki/Hash_per_second'><span>300 quadrillion SHA-256 hashes per second</span></a><span>. That&#39;s </span><strong><span>300×10</span><sup><span>15</span></sup><span> hashes per second</span></strong><span>.</span></p><p><span>Let&#39;s say you were trying to perform a </span><a href='https://en.wikipedia.org/wiki/Collision_attack'><span>collision attack</span></a><span> and would &quot;only&quot; need to calculate </span><strong><span>2</span><sup><span>128</span></sup><span> hashes</span></strong><span>. At the rate Bitcoin is going, it would take them</span></p><p><span>2</span><sup><span>128</span></sup><span>/(300 × 10</span><sup><span>15</span></sup><span> × 86400 × 365.25) ≈ </span><strong><span>3.6×10</span><sup><span>13</span></sup><span> years</span></strong><span>.</span></p><p><span>In comparison, our universe is only about </span><strong><span>13.7×10</span><sup><span>9</span></sup></strong><span>. Brute-force guessing is not a practical option.</span></p></blockquote><h2><a name="how-does-binary-and-hexadecimal-work" class="md-header-anchor"></a><span>How Does Binary and Hexadecimal Work?</span></h2><p><span>Just a quick checker on how binary and hexadecimal works, computers can only read </span><code>0</code><span> and </span><code>1</code><span> and so we count in </span><strong><span>base 2</span></strong><span>, or </span><strong><span>binary</span></strong><span>. Usually, we count in </span><strong><span>bytes</span></strong><span>, or 8 bits, a number that can represent </span><strong><span>0-255 (2</span><sup><span>8</span></sup><span>)</span></strong><span>.</span></p><p><span>We can also represent them in </span><strong><span>hexadecimal</span></strong><span>, or </span><strong><span>base 16</span></strong><span>, using characters </span><code>0-9</code><span>and</span><code>ABCDEF</code></p><hr /><p><span>Here is </span><code>255</code><span> in binary, or </span><strong><span>2</span><sup><span>8</span></sup></strong><span>-1, just ignore the 0b as that just means it represents binary.</span></p><blockquote><p><strong><span>0b</span></strong><span>11111111</span></p></blockquote><p><span>Here is </span><code>255</code><span> in hexadecimal, or </span><strong><span>16</span><sup><span>2</span></sup><span>-1</span></strong><span> </span><strong><span>(2</span><sup><span>8</span></sup><span>-1)</span></strong><span>, just ignore the 0x as that just means it represents hexadecimal.</span></p><blockquote><p><strong><span>0x</span></strong><span>FF</span></p></blockquote><p><span>We can </span><strong><span>represent larger numbers</span></strong><span> like so </span><strong><span>(16</span><sup><span>4</span></sup><span>)-1</span></strong><span> or </span><strong><span>(2</span><sup><span>16</span></sup><span>)-1</span></strong><span> which equals </span><code>65535</code><span>:</span></p><blockquote><p><strong><span>0x</span></strong><span>FF FF</span></p><p><strong><span>0b</span></strong><span>11111111 11111111</span></p></blockquote><h2><a name="what-is-randomness" class="md-header-anchor"></a><span>What Is Randomness?</span></h2><p><strong><span>Randomness</span></strong><span> is a term that can mean a lot of things, but in cryptography, it is mostly suited to mean the randomness that is needed to generate a private key. We can not safely generate a private key without some form of randomness, usually provided by the operating system or by the userspace PRNG. You will see some terms you may not be familiar with. Here are some of them:</span></p><ul><li><p><strong><span>CSPRNG:</span></strong><span> Cryptographically secure pseudorandom number generator</span></p></li><li><p><strong><span>PRNG:</span></strong><span> Pseudorandom number generator</span></p><ul><li><strong><span>DRBG</span></strong><span>: Deterministic Random Bit Generator</span></li></ul></li><li><p><strong><span>RNG:</span></strong><span> Random Number Generator</span></p></li></ul><h1><a name="how-lamport-signatures-work" class="md-header-anchor"></a><span>How Lamport Signatures Work</span></h1><p><span>Read </span><a href='https://cryptoservices.github.io/quantum/2015/12/04/one-time-signatures.html'><span>Hash-Based Signatures Part I: One-Time Signatures (OTS)</span></a></p><h2><a name="overview" class="md-header-anchor"></a><span>Overview</span></h2><h2><a name="the-basic-idea" class="md-header-anchor"></a><span>The Basic Idea</span></h2><p><span>The Basic Idea of Lamport Signatures is to have </span><strong><span>two secret keys</span></strong><span> (x|y) each of 32-bytes (or more) for every bit of an input that we have where:</span></p><blockquote><p><span>0 = x</span></p></blockquote><blockquote><p><span>1 = y</span></p></blockquote><p><span>Then, we perform a given </span><strong><span>hash function</span></strong><span> on both x and y like so to become our public key:</span></p><blockquote><p><code>h(x)</code><span> | </span><code>h(y)</code></p></blockquote><p><span>We release this public key and to sign the given message, we only release the secret keys with the corresponding bits in the input.</span></p><p><span>The verifier can then verify each secret key by hashing it so that it matches the given public key.</span></p><h3><a name="planning-phase" class="md-header-anchor"></a><span>Planning Phase</span></h3><p><span>First, you will need to know:</span></p><ul><li><p><code>n</code><span> | The </span><strong><span>number of bytes</span></strong><span> you would like to </span><strong><span>Sign</span></strong><span> with your </span><strong><span>Keypair</span></strong></p><ul><li><code>keypairs</code><span> = </span><code>n x 8 x 2</code></li></ul></li><li><p><code>d</code><span> | the </span><strong><span>byte-size of each of your private keys</span></strong></p><ul><li><code>d ∈ {32,48,64}</code></li><li><span>Larger values of </span><code>d</code><span> result in </span><strong><span>larger private key sizes</span></strong><span> and </span><strong><span>larger signatures</span></strong><span> but are more secure</span></li></ul></li><li><p><code>hash_function</code><span> | the </span><strong><span>chosen hash function</span></strong><span> you will use to generate the public key and for use in verification</span></p><ul><li><span>Best Practice would be to chose a secure hash function with at least a 256-bit digest size.</span></li></ul></li></ul><h3><a name="generation-phase" class="md-header-anchor"></a><span>Generation Phase</span></h3><p><span>We first need a </span><strong><span>CSPRNG</span></strong><span> (Cryptographically secure pseudorandom number generator) to generate our private keys for us. These private keys will need to be of the length of 32 bytes (256 bits) or more.</span></p><ol start='' ><li><p><span>Choose the available length of the </span><strong><span>input</span></strong><span> you would like to sign (</span><code>n</code><span>) and generate from a </span><strong><span>CSPRNG</span></strong><span> as many secret keys (</span><code>n x 8 x 2</code><span>) as required to sign </span><code>n</code><span>.</span></p><ol start='' ><li><span>Signing 64 bytes (512-bits) will take 1024 keypairs each of </span><code>d</code><span>-size</span></li></ol></li><li><p><span>With the hash function you have chosen, hash each secret key to get the Public Key</span></p><ol start='' ><li><code>PK</code><span> = </span><code>h(x)</code><span> | </span><code>h(y)</code><span> for as many secret keys as you have</span></li></ol></li></ol><h3><a name="signing-phase" class="md-header-anchor"></a><span>Signing Phase</span></h3><p><span>To sign a selected input, first convert the input to </span><strong><span>binary</span></strong><span>. Then for each bit, do the following:</span></p><ul><li><p><span>If the bit is a </span><code>0</code><span> </span></p><ul><li><span>Publish the secret key for </span><code>x</code></li></ul></li><li><p><span>If the bit is a </span><code>1</code></p><ul><li><span>Publish the secret key for </span><code>y</code></li></ul></li></ul><p><span>And this creates your one-time signature.</span></p><h3><a name="verification-phase" class="md-header-anchor"></a><span>Verification Phase</span></h3><p><span>The verifier can then check the signatures by converting the input to binary and like the signing phase:</span></p><ul><li><p><span>if the bit is a </span><code>0</code></p><ul><li><span>Hash the signature to see if it matches the </span><code>Public Key (x)</code></li></ul></li><li><p><span>if the bit is a </span><code>1</code></p><ul><li><span>Hash the signature to see if it matches the </span><code>Public Key (y)</code></li></ul></li></ul><h1><a name="how-winternitz-one-time-signatures-work" class="md-header-anchor"></a><span>How Winternitz One-Time Signatures Work</span></h1><h2><a name="overview-n167" class="md-header-anchor"></a><span>Overview</span></h2><p><strong><span>THIS SECTION IS UNFINISHED</span></strong></p><p><span>Read </span><a href='https://tools.ietf.org/html/rfc8391#section-3.1'><span>RFC8391 - WOTS+</span></a></p><p><span>Read </span><a href='https://cryptoservices.github.io/quantum/2015/12/04/one-time-signatures.html'><span>Hash-Based Signatures Part I: One-Time Signatures (OTS)</span></a></p><p><span>Read </span><a href='https://iota.stackexchange.com/questions/645/can-someone-explain-very-simplified-how-the-winternitz-ots-lamport-ots-works'><span>Can someone explain very simplified how the Winternitz OTS/Lamport OTS works?</span></a></p><p><span>Read </span><a href='http://tuprints.ulb.tu-darmstadt.de/3651/1/Thesis.pdf'><span>Huelsing13</span></a></p><h2><a name="the-basic-idea-n169" class="md-header-anchor"></a><span>The Basic Idea</span></h2><p><img src="https:\\0xAtropine.github.io\blog\5\WOTS.PNG" referrerpolicy="no-referrer" alt="WOTS"></p><p><span>Public Key = h</span><sup><span>w</span></sup><span>(x)</span></p><p><span>Secret Key = x</span></p><p><span>Number of Secret Keys depend on </span><code>n</code><span> and </span><code>w</code></p><hr /><p><span>A parameter, known as the </span><strong><span>Winternitz Parameter</span></strong><span> </span><code>w</code><span> exists that is used to compute the number of hashing cycles that are completed to create the public key.</span></p><p><code>w ∈ {4,16,256}</code></p><p><code>n</code><span> | the message length, the length of the private key, public key, or signature element in bytes</span></p><p><span>The idea is that we can sign </span><strong><span>multiple bits</span></strong><span> with a single secret key by simply hashing the secret key multiple times, with the Winternitz parameter being a representation of the cycles of hashes we compute. It can be thought of signing in base 2, so:</span></p><ul><li><span>4 cycles signs 2 bits</span></li><li><span>16 cycles signs 4 bits</span></li><li><span>256 cycles signs 8 bits (or one byte)</span></li></ul><p><span>The size of </span><code>w</code><span> gives a trade-off between signature size and speed of signing/verification, with a larger value of </span><code>w</code><span> signing/verifying at a slower-speed but with a smaller signature.</span></p><p><code>w = 16</code><span> gives the best trade-off between speed and signature size as the value of </span><code>w</code><span> grows exponentially, as stated in </span><strong><span>RFC8391</span></strong><span>.</span></p><p><span>The </span><strong><span>hashing function</span></strong><span> that is used will also play an important role in both the speed and signature size, with the digest size affecting the signature and public key size, and the hashing function speed affecting the verification/signing speed.</span></p><p><span>As a basic idea of how signing works, lets say we are using </span><code>w = 256</code><span> to sign a single byte and that byte is decimal </span><code>65</code><span> or ASCII </span><code>A</code><span> represented in binary as:</span></p><p><code>0b01000001</code></p><p><span>We would first make our public key by signing the secret key 256 times with the hash function, with each output being the next input.</span></p><p><span>Then, to sign the byte, we would simply hash the secret key 65 times.</span></p><p><span>The verifier would then hash that until it reaches the public key so the verifier can verify it is right.</span></p><h1><a name="my-reference-implementation-of-lamport-signatures" class="md-header-anchor"></a><span>My Reference Implementation of Lamport Signatures</span></h1><p><span>View my reference implementation: </span><a href='https://github.com/0xAtropine/Leslie-Lamport'><span>[Rust] Leslie-Lamport</span></a><span> | </span><a href='https://docs.rs/leslie_lamport/0.2.1/leslie_lamport/'><span>Docs</span></a></p><hr /><h2><a name="why-do-i-believe-it-is-secure" class="md-header-anchor"></a><span>Why Do I Believe It Is Secure?</span></h2><ul><li><span>It is programmed using all safe </span><strong><span>Rust</span></strong><span>.</span></li><li><span>The Private Key Randomness is from the </span><strong><span>getrandom</span></strong><span> crate which is cross-compatible with the majority of operating systems and gets its cryptographic randomness directly from the </span><strong><span>OS CSPRNG</span></strong><span>.</span></li><li><span>For Public Keys, it can use three hashing algorithms, two of which (</span><strong><span>OS_SHA256</span></strong><span> and </span><strong><span>OS_SHA512</span></strong><span>) come directly from the </span><strong><span>Operating System&#39;s Crypto API</span></strong><span>.</span></li></ul><p><strong><span>TLDR:</span></strong><span> It&#39;s secure because it takes full advantage of the </span><strong><span>Operating System&#39;s Crypto API</span></strong></p><h2><a name="how-to-use" class="md-header-anchor"></a><span>How To Use</span></h2><h3><a name="secure-generation" class="md-header-anchor"></a><span>Secure Generation</span></h3><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="rust"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="rust"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre>x</pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">use</span> <span class="cm-variable">leslie_lamport</span>::{<span class="cm-variable">LamportKeyPair</span>,<span class="cm-variable">LamportSignature</span>,<span class="cm-variable">Algorithms</span>};</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">fn</span> <span class="cm-def">main</span>(){</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-comment">// Generate Keypair using Operating System SHA256</span></span></pre><div class="" style="position: relative;"><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">let</span> <span class="cm-def">keypair</span> <span class="cm-operator">=</span> <span class="cm-variable">LamportKeyPair</span>::<span class="cm-variable">generate</span>(<span class="cm-variable">Algorithms</span>::<span class="cm-variable">OS_SHA256</span>);</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-comment">// Generate Keypair using Operating System SHA512</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">let</span> <span class="cm-def">keypair_sha512</span> <span class="cm-operator">=</span> <span class="cm-variable">LamportKeyPair</span>::<span class="cm-variable">generate</span>(<span class="cm-variable">Algorithms</span>::<span class="cm-variable">OS_SHA512</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-comment">// Generate Keypair using Rust Library For Blake2b</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">let</span> <span class="cm-def">keypair_blake2b</span> <span class="cm-operator">=</span> <span class="cm-variable">LamportKeyPair</span>::<span class="cm-variable">generate</span>(<span class="cm-variable">Algorithms</span>::<span class="cm-variable">BLAKE2B</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 437px;"></div><div class="CodeMirror-gutters" style="display: none; height: 437px;"></div></div></div></pre><h2><a name="more-information" class="md-header-anchor"></a><span>More Information</span></h2><p><span>This Rust Library implements the following:</span></p><figure><table><thead><tr><th><span>Actions</span></th><th style='text-align:left;' ><span>Description</span></th></tr></thead><tbody><tr><td><span>Generation</span></td><td style='text-align:left;' ><span>Default Generation of 1024 keypairs (x</span><span>|</span><span>y) of a default secret key length of 32 bytes (256 bits)</span></td></tr><tr><td><span>Signing</span></td><td style='text-align:left;' ><span>Can Sign Up To 512-bits of hexadecimal</span></td></tr><tr><td><span>Verification</span></td><td style='text-align:left;' ><span>Returns Boolean</span></td></tr><tr><td><span>Serialization</span></td><td style='text-align:left;' ><span>Serializes using </span><strong><span>serde</span></strong></td></tr><tr><td><span>Deserialization</span></td><td style='text-align:left;' ><span>Deserializes using </span><strong><span>serde</span></strong></td></tr><tr><td><span>Algorithms Enum</span></td><td style='text-align:left;' ><span>Provides Operating System SHA256 and SHA512 and a Rust Library for Blake2B</span></td></tr></tbody></table></figure><p><span>For more information, refer below:</span></p><hr /><ul><li><p><strong><span>For the Generation of Private Keys</span></strong><span>, the library uses the </span><strong><span>Kernel CSPRNG</span></strong><span> and creates private keys of size </span><code>d</code><span>  where </span><code>d ∈ {32,48,64}</code><span> with a default of </span><code>d = 32</code><span> or </span><code>256 bits</code></p><ul><li><span>This is done through the use of the </span><strong><span>Portable, Cross-Platform</span></strong><span> </span><a href='https://github.com/rust-random/getrandom'><span>getrandom</span></a><span> crate as opposed to </span><a href='https://docs.rs/rand/0.7.3/rand/'><span>rand</span></a></li></ul></li><li><p><strong><span>For the Generation of the Public Key</span></strong><span>, the choice of three hashing algorithms are given, two of which are wrappers around the Operating Systems Crypto API.</span></p><ul><li><strong><span>OS_SHA256</span></strong><span> and </span><strong><span>OS_SHA512</span></strong><span> are wrappers around the </span><strong><span>Operating Systems Crypto API</span></strong><span> using the </span><a href='https://crates.io/crates/crypto-hash'><span>crypto-hash</span></a><span> crate</span></li><li><strong><span>BLAKE2B</span></strong><span> is done through the rust library </span><a href='https://crates.io/crates/blake2-rfc'><span>blake2-rfc</span></a><span> with a default digest size of 32 bytes</span></li><li><span>All Hash Functions provide at least a </span><strong><span>32 byte (256bit) digest</span></strong><span>, with SHA512 providing </span><strong><span>64 bytes (512bits)</span></strong></li></ul></li><li><p><strong><span>Can Sign Up To 512-bits (64 bytes)</span></strong><span> by default</span></p><ul><li><p><span>A default of 1024 Private Keys are generated by default of </span><strong><span>d-size bytes</span></strong><span> where: </span></p><ul><li><code>d ∈ {32,48,64} bytes</code><span> with a default of </span><code>d = 32</code><span> or </span><code>256 bits</code></li></ul></li></ul></li><li><p><span>Remains </span><strong><span>Post-Quantum Secure</span></strong><span>, including the hash functions chosen.</span></p></li></ul><ul><li><strong><span>Serialization, Deserialization</span></strong><span> implemented through the derivation of Rust&#39;s </span><a href='https://serde.rs/'><span>serde</span></a><span>.</span></li></ul><hr /><h1><a name="homepage" class="md-header-anchor"></a><span>Homepage</span></h1><p><span>Visit my </span><a href='/index.html/../'><span>Homepage</span></a></p></div>
</body>
</html>